// -*- mode: c++ -*-
// Copyright (c) 2005-2009 Jaroslav Gresula
//
// Distributed under the MIT license (See accompanying file
// LICENSE.txt or copy at http://jagpdf.org/LICENSE.txt)


#include "precompiled.h"
#include "t1adobestandardfonts.h"

// this file was generated by afm_parser.py on

// if face.EncodingScheme != FontSpecific then  glyphs sorted by unicode
//                                        else  glyphs sorted by code

namespace jag {
namespace resources {

#ifdef __GNUC__
# define JAG_PACKED __attribute__((packed))
#else
# define JAG_PACKED 
#endif


#if defined(_MSC_VER)
# pragma pack(push, 1)
#endif

struct JAG_PACKED kern_rec_t
{
    jag::UInt key;
    unsigned offset_0 : 6;
    unsigned offset_1 : 6;
    unsigned offset_2 : 6;
    unsigned offset_3 : 6;
    unsigned offset_4 : 6;
    unsigned offset_5 : 6;
    unsigned offset_6 : 6;
    unsigned offset_7 : 6;
};

#if defined(_MSC_VER)
# pragma pack(pop)
#endif 
#undef JAG_PACKED

// compile time assertion on kern_rect_t size
#if defined(_MSV_VER) or defined(__GNUC__)
typedef int check_packing[(sizeof(kern_rec_t) == 10) ? 1 : -1 ];
#endif 

namespace {

// --- kerning pairs

const unsigned KERN_HASH_P[4] = {$hash1_p, $hash2_p, $hash3_p, 0};
const unsigned KERN_HASH_TABLE_SIZE = $hash_table_size;
const int KERN_MIN_UNICODE = $min_unicode;
const int KERN_MAX_UNICODE = $max_unicode;

const kern_rec_t kerning_table[KERN_HASH_TABLE_SIZE] =
{
    $kerning_table
};

const short kern_values[] =
{
    $kern_values
};

$kerning_getters

// --- face definitions

$FACE_DEFS

} // anonymous namespace

extern t1s_face const* g_adobe_standard_t1_faces[T1_NUM_FACES] = {
    $FACE_PTRS
};


//
//
// 
Int t1_get_kerning(t1s_face const& face, Int left, Int right)
{
    if (!face.kerning_getter)
        return 0;

    unsigned key = left + (right << 14);
    for(unsigned const *p = &KERN_HASH_P[0]; *p; ++p)
    {
        unsigned i = (key % *p) % KERN_HASH_TABLE_SIZE;
        if (kerning_table[i].key == key)
        {
            int val = (*face.kerning_getter)(kerning_table[i]);
            if (val >= 0 &&
                left >= KERN_MIN_UNICODE && left <= KERN_MAX_UNICODE &&
                right >= KERN_MIN_UNICODE && right <= KERN_MAX_UNICODE)
            {
                return kern_values[val];
            }
            else
            {
                return 0;
            }
        }
    }

    return 0;
}

}} //namespace jag::resources
/** EOF @file */
