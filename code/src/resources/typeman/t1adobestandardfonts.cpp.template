// -*- mode: c++ -*-
// Copyright (c) 2005-2009 Jaroslav Gresula
//
// Distributed under the MIT license (See accompanying file
// LICENSE.txt or copy at http://jagpdf.org/LICENSE.txt)


#include "precompiled.h"
#include "t1adobestandardfonts.h"
#include <boost/cstdint.hpp>

// this file was generated by afm_parser.py on

// if face.EncodingScheme != FontSpecific then  glyphs sorted by unicode
//                                        else  glyphs sorted by code

namespace jag {
namespace resources {

#ifdef __GNUC__
# define JAG_PACKED __attribute__((packed))
#else
# define JAG_PACKED 
#endif


#if defined(_MSC_VER)
# pragma pack(push, 1)
#endif

struct JAG_PACKED kern_rec_t
{
    boost::uint32_t key;
    unsigned offset_0 : 6;
    unsigned offset_1 : 6;
    unsigned offset_2 : 6;
    unsigned offset_3 : 6;
    unsigned offset_4 : 6;
    unsigned offset_5 : 6;
    unsigned offset_6 : 6;
    unsigned offset_7 : 6;
};

bool operator<(kern_rec_t const& lhs, kern_rec_t const& rhs)
{
    return lhs.key < rhs.key;
}

#if defined(_MSC_VER)
# pragma pack(pop)
#endif 
#undef JAG_PACKED

// compile time assertion on kern_rect_t size
#if defined(_MSV_VER) or defined(__GNUC__)
typedef int check_packing[(sizeof(kern_rec_t) == 10) ? 1 : -1 ];
#endif 

namespace {

// --- kerning pairs

#if defined(JAG_KERN_BINARY_SEARCH)

const unsigned KERN_SORTED_LEN = $kern_sorted_len;

const kern_rec_t sorted_kerning_table[KERN_SORTED_LEN] =
{
    $kerning_sorted
};

#else 

const unsigned NUM_HASH_FUNCTIONS = $num_hash_functions;
const unsigned KERN_HASH_P[3] = {$hash1_p, $hash2_p, $hash3_p};
const unsigned KERN_HASH_TABLE_SIZE = $hash_table_size;
const int KERN_MIN_UNICODE = $min_unicode;
const int KERN_MAX_UNICODE = $max_unicode;

const kern_rec_t kerning_table[KERN_HASH_TABLE_SIZE] =
{
    $kerning_table
};

#endif 

const short kern_values[] =
{
    $kern_values
};

$kerning_getters

// --- TEST START optional linear search



// --- TEST END optional linear search

// --- face definitions

$FACE_DEFS

} // anonymous namespace

extern t1s_face const* g_adobe_standard_t1_faces[T1_NUM_FACES] = {
    $FACE_PTRS
};

#if defined(JAG_KERN_BINARY_SEARCH)
//
// TEST
//
struct kern_cmp
{
    bool operator()(kern_rec_t const& rec, unsigned key) const
    {
        return rec.key < key;
    }

    bool operator()(unsigned key, kern_rec_t const& rec) const
    {
        return key < rec.key;
    }
};

Int t1_get_kerning(t1s_face const& face, Int left, Int right)
{
    if (!face.kerning_getter)
        return 0;

    unsigned key = (left & 0xffff)+ (right << 16);
    const kern_rec_t *found = std::lower_bound(sorted_kerning_table,
                                               sorted_kerning_table + KERN_SORTED_LEN,
                                               key,
                                               kern_cmp());
    if (found->key == key)
    {
        int val = (*face.kerning_getter)(*found);
        return kern_values[val];
    }
        
    return 0;
}

#else 

//
//
// 
Int _t1_get_kerning(t1s_face const& face, Int left, Int right)
{
    if (!face.kerning_getter)
        return 0;

    unsigned key = (left & 0xffff) + (right << 16);
    for(unsigned const *p = &KERN_HASH_P[0];
        p < KERN_HASH_P + NUM_HASH_FUNCTIONS;
        ++p)
    {
        unsigned i = (key % *p) % KERN_HASH_TABLE_SIZE;
        if (kerning_table[i].key == key)
        {
            int val = (*face.kerning_getter)(kerning_table[i]);
            return kern_values[val];
        }
    }
    return 0;
}

Int t1_get_kerning(t1s_face const& face, Int left, Int right)
{
    if (!face.kerning_getter)
        return 0;

    unsigned key = (left & 0xffff) + (right << 16);
    unsigned i = (key % $hash1_p) % KERN_HASH_TABLE_SIZE;
    if (kerning_table[i].key != key)
    {
        i = (key % $hash2_p) % KERN_HASH_TABLE_SIZE;
        if (kerning_table[i].key != key)
        {
//             i = (key % $hash3_p) % KERN_HASH_TABLE_SIZE;
//             if (kerning_table[i].key != key)
                return 0;
        }
    }

    int val = (*face.kerning_getter)(kerning_table[i]);
    return kern_values[val];
}

#endif 



}} //namespace jag::resources
/** EOF @file */
